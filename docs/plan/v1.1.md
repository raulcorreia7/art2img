# art2img v1.1 â€“ Public API Architecture

Scope: Refresh the v1.1 design so the public surface is clean, modern, and strongly memory-first. Filesystem adapters remain optional layers on top of the in-memory API.

## Goals

- Deliver an intuitive, documented C++23 API that favours composable free functions and lightweight value types.
- Put memory-based workflows first. File access, GRP discovery, and CLI behaviour live in adapters built on top of the core API.
- Maintain compatibility with existing behaviour while allowing opt-in upgrades through clear migration helpers.
- Preserve testability: every public contract is unit-testable without touching disk.

## Architectural Principles

1. **Layered modules**: `core` (pure data + algorithms), `adapters` (I/O, GRP, metadata), `extras` (optional helpers). Each namespace mirrors the directory layout.
2. **Memory-first contracts**: All public entry points accept `std::span`, `std::string_view`, or lightweight owning containers supplied by the caller. File paths appear only in adapter layers.
3. **Functional flow**: Free functions return `std::expected<T, Error>`; no implicit state machines. Value types are plain structs with explicit invariants.
4. **Extensibility by composition**: Advanced behaviours (batch conversion, CLI defaults) compose the primitive functions; no inheritance hierarchies.
5. **Predictable performance**: Avoid hidden allocations. Callers own buffers, can reuse workspaces, and opt-in to post-processing steps.

## Module Layout

```
include/
  art2img/
    api.hpp                      // barrel include for the stable surface
    version.hpp                  // semantic version + feature flags
    core/
      error.hpp                  // errc, Error, helpers
      art.hpp                    // ArtArchive, TileView, tile_count()
      palette.hpp                // Palette, PaletteView, load_palette()
      convert.hpp                // ConversionOptions, palette_to_rgba(), postprocess_rgba()
      image.hpp                  // RgbaImage, ImageView, stride utilities
      encode.hpp                 // ImageFormat, EncoderOptions, encode_image()
      meta.hpp                   // AnimationData, Manifest models
    adapters/
      io.hpp                     // read_binary_file(), write_file()
      grp.hpp                    // GrpFile, load_grp(), GrpFile::entry()
      meta_serialization.hpp     // format_animation_ini/json(), parse_manifest()
    extras/
      batch.hpp                  // high-level helpers (optional)
src/
  core/
    art.cpp, convert.cpp, encode.cpp, error.cpp, image.cpp, palette.cpp
  adapters/
    io.cpp, grp.cpp, meta_serialization.cpp
  extras/
    batch.cpp
  cli/main.cpp
```

### Namespaces

- `art2img::core`
- `art2img::adapters`
- `art2img::extras`

`api.hpp` re-exports the stable subset for consumers; internal helpers remain hidden.

## Public Types and Functions

### Errors

```cpp
namespace art2img::core {

enum class errc : std::uint8_t {
  io_failure = 1,
  invalid_art,
  invalid_palette,
  conversion_failure,
  encoding_failure,
  unsupported,
  no_animation
};

struct Error {
  std::error_code code;
  std::string message;
};

Error make_error(errc code, std::string message);
std::error_code make_error_code(errc) noexcept;  // std::is_error_code_enum specialization provided.

} // namespace art2img::core
```

### Core data models (memory only)

```cpp
namespace art2img::core {

struct TileMetrics {
  std::uint32_t width;
  std::uint32_t height;
};

struct ArtArchive {
  std::span<const std::byte> raw;            // full ART buffer
  std::vector<TileMetrics> layout;           // tile count inferred at load time
};

struct TileView {
  std::span<const std::byte> indices;        // column-major palette indices
  std::uint32_t width;
  std::uint32_t height;
};

struct PaletteView {
  std::span<const std::uint8_t> rgb;         // 256 * 3 bytes
};

struct Palette {
  std::array<std::uint8_t, 256 * 3> rgb;
};

struct RgbaImage {
  std::uint32_t width;
  std::uint32_t height;
  std::vector<std::uint8_t> pixels;          // row-major RGBA8
};

struct RgbaImageView {
  std::span<const std::uint8_t> pixels;
  std::uint32_t width;
  std::uint32_t height;
  std::uint32_t stride;                      // bytes per row
};

struct ConversionOptions {
  bool apply_lookup = false;
  std::optional<std::uint8_t> shade_index;
};

struct PostprocessOptions {
  bool apply_transparency_fix = true;
  bool premultiply_alpha = false;
  bool sanitize_matte = false;
};

} // namespace art2img::core
```

### Core algorithms

```cpp
namespace art2img::core {

std::expected<ArtArchive, Error>
load_art(std::span<const std::byte> blob) noexcept;

std::size_t
tile_count(const ArtArchive&) noexcept;

std::optional<TileView>
get_tile(const ArtArchive&, std::size_t tile_index) noexcept;

std::expected<Palette, Error>
load_palette(std::span<const std::byte> blob) noexcept;

PaletteView
view_palette(const Palette&) noexcept;

std::expected<RgbaImage, Error>
palette_to_rgba(const TileView&, PaletteView, ConversionOptions = {});

void
postprocess_rgba(RgbaImage&, PostprocessOptions = {});

} // namespace art2img::core
```

### Encoding layer (still memory-first)

```cpp
namespace art2img::core {

enum class ImageFormat : std::uint8_t { png, tga, bmp };

enum class CompressionPreset : std::uint8_t { balanced, fast, smallest };

enum class BitDepth : std::uint8_t { auto_detect, bpp24, bpp32 };

struct EncoderOptions {
  CompressionPreset compression = CompressionPreset::balanced;
  BitDepth bit_depth = BitDepth::auto_detect;
};

struct EncodedImage {
  ImageFormat format;
  std::uint32_t width;
  std::uint32_t height;
  std::vector<std::byte> bytes;
};

std::expected<EncodedImage, Error>
encode_image(const RgbaImageView&, ImageFormat format, EncoderOptions = {});

constexpr std::string_view
file_extension(ImageFormat) noexcept;

} // namespace art2img::core
```

### Metadata models

```cpp
namespace art2img::core {

struct FrameRange { std::uint32_t first; std::uint32_t count; };

struct AnimationData {
  std::string name;
  FrameRange frames;
  std::chrono::milliseconds frame_time{0};
  bool loops = true;
};

struct ExportManifest {
  std::string palette_name;
  std::vector<AnimationData> animations;
};

} // namespace art2img::core
```

## Adapter contracts (file-aware but optional)

```cpp
namespace art2img::adapters {

std::expected<std::vector<std::byte>, core::Error>
read_binary_file(const std::filesystem::path&);

std::expected<void, core::Error>
write_file(const std::filesystem::path&, std::span<const std::byte> data);

struct GrpEntry {
  std::string name;           // normalised, case-insensitive
  std::span<const std::byte> data;
};

class GrpFile {
 public:
  const std::vector<GrpEntry>& entries() const noexcept;
  std::optional<GrpEntry> entry(std::string_view name) const noexcept;
};

std::expected<GrpFile, core::Error>
load_grp(std::span<const std::byte> blob) noexcept;

std::expected<std::string, core::Error>
format_animation_ini(const core::ExportManifest&);

std::expected<std::string, core::Error>
format_animation_json(const core::ExportManifest&);

} // namespace art2img::adapters
```

`extras::batch` can expose ergonomic helpers such as `convert_tiles(const BatchRequest&)` that orchestrate core and adapter calls without hiding the underlying primitives.

## CLI and Tooling Guidance

- CLI stays thin: parse arguments, resolve files, feed byte buffers to the core functions, write results using adapters.
- Deprecate negative flags (e.g. `--no-transparency-fix`) in favour of explicit enumerations (`--transparency-fix on|off`). Emit warnings for legacy forms until removal.
- Provide `--palette SOURCE` switches where `SOURCE` can be a file path or GRP entry; resolution happens through adapters.
- Emit structured logs (JSON lines) behind a `--emit-log` flag for automation environments.

## Migration Strategy

1. Remove the `fmt` dependency; rely on `std::format`.
2. Introduce the new directory structure and namespaces. Provide transitional headers with `[[deprecated]]` aliases for one minor release.
3. Refactor implementations to use the memory-first contracts while keeping behaviour parity. Add doctest coverage for each public free function.
4. Update adapters and CLI to call into the new API. Ensure adapters are the only layer touching filesystem or GRP discovery.
5. Document the new API in `README.md`, `USAGE.md`, and `docs/MIGRATION.md`.

## Risk Controls

- **Namespace/header migration**: use automated sed-based scripts guarded by CI to prevent regressions.
- **GRP validation**: run integration tests against known-good Duke3D GRP files stored outside the repo (`~/games/duke3d/DUKE3D.GRP`).
- **Backward compatibility**: transitional aliases log warnings; documentation clearly describes the upgrade path.
- **Performance**: add Google Benchmark targets that exercise `palette_to_rgba` and `encode_image` across formats. Treat regressions as blockers.

## Testing Strategy

- Unit tests for each pure function in `core` using in-memory fixtures.
- Adapter tests using temporary directories and in-memory GRP samples.
- CLI integration smoke tests verifying argument parsing and happy-path conversions.
- Performance suite (Phase 10) capturing tile throughput, memory footprint, and encoder characteristics.

## Acceptance Criteria

- Public headers in `include/art2img/` reflect the API shown above.
- Core functions operate solely on caller-supplied memory buffers.
- Adapters remain optional; library consumers can integrate their own file pipelines.
- Tests cover success and failure paths for all public functions.
- Documentation showcases memory-first usage patterns with minimal boilerplate.
