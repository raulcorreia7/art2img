Scope: reanalyzed current repo; tightened architecture; set contracts; specified implementation details; enumerated tasks.

# Architectural Review Summary

**Overall Assessment**: The v1.1 plan is well-structured and architecturally sound. The phased approach minimizes risk and provides clear migration paths.

## Key Strengths ✅

1. **Progressive Migration**: Phased implementation reduces risk and allows incremental validation
2. **Clear Separation**: Core/adapters/extras structure provides excellent modularity
3. **Backward Compatibility**: Deprecation aliases and flag compatibility ease migration
4. **Memory-First Design**: GRP integration aligns with modern C++ patterns
5. **Standard Compliance**: C++23 + std::format ensures future compatibility

## Critical Issues & Risks ⚠️

1. **Phase 1 High Risk**: Header/namespace migration affects 50+ test files - requires automated tooling
2. **Missing GRP Specification**: Need actual Duke3D GRP files for testing (use `~/games/duke3d` or `~/games/duke3d/DUKE3D.GRP`)
3. **Undefined extras/ Directory**: Purpose and contents not specified in plan
4. **CLI Contract Inconsistency**: Plan mentions removing `--offset/--size` but CLI contract shows support

## Updated Requirements

- **GRP Testing**: Use `~/games/duke3d` or `~/games/duke3d/DUKE3D.GRP` for GRP format validation
- **Migration Tools**: Develop automated scripts for header/namespace migration
- **extras/ Clarification**: Specify purpose of extras/ directory

# Reality check: current state

* CLI links `fmt` in CMake only; code already uses `std::format`. Remove fmt CMake dependency. 
* Encoding API already exposes PNG/TGA/BMP and per-format options; keep, surface in `core::encode.hpp`.
* Conversion stack uses `to_rgba`, `copy_column_major_to_row_major`, and a `ColumnMajorRowRange` helper; rename to `palette_to_rgba` and delete the row-range helper from the public surface. Keep internal if helpful.  
* Animation export writes legacy INI only; add JSON writer alongside INI. 
* USAGE shows negative flag `--no-transparency-fix`; replace with positive `--apply-transparency-fix on|off`, and deprecate old flags with warnings. 

# Target architecture (library-first, CLI-thin)

```
include/
  art2img/
    api.hpp                          // barrel include
    core/
      types.hpp                      // Error, errc, small aliases
      art.hpp                        // ArtData, TileView, tile(), tile_count()
      palette.hpp                    // Palette, load_palette(span<byte>)
      convert.hpp                    // palette_to_rgba(), postprocess_rgba()
      encode.hpp                     // Image{w,h,rgba}, ImageFormat{png,tga,bmp}, EncodedImage, encode_image()
      meta.hpp                       // AnimationData, ExportManifest models
    adapters/
      io.hpp                         // read_binary_file(), write_{binary,text}_file()
      grp.hpp                        // parse_grp(), grp_find()
      meta_json.hpp                  // format_animation_meta_json(), format_manifest_json(), format_manifest(meta::format)
    extras/
      // Optional components (CLI utilities, batch processing helpers, 
      // experimental format converters, compatibility shims)
src/
  core/
    art.cpp
    convert.cpp
    encode.cpp
    error.cpp
    palette.cpp
    types.cpp
  adapters/
    io.cpp
    animation.cpp    # moved from src/animation.cpp
    grp.cpp          # new
    meta_json.cpp    # new
  cli/main.cpp
docs/
  README.md, USAGE.md, MIGRATION.md
tests/
  unit/*  integration/*
```

Namespaces: `art2img::v1::core`, `art2img::v1::adapters`, `art2img::v1::extras`.

# Contracts (public, stable)

## Core types

```cpp
namespace art2img::v1::core {

enum class errc : std::uint8_t { io_failure=1, invalid_art, invalid_palette, conversion_failure, encoding_failure, unsupported, no_animation };
struct Error { std::error_code code; std::string message; };

struct TileView {
  const std::uint8_t* data; std::uint32_t w, h;  // column-major palette indices
  inline std::size_t col_major_offset(std::uint32_t x,std::uint32_t y) const noexcept { return std::size_t(x)*h + y; }
  inline std::uint8_t at(std::uint32_t x,std::uint32_t y) const noexcept { return data[col_major_offset(x,y)]; }
};

struct Image { std::uint32_t w,h; std::vector<std::uint8_t> rgba; }; // row-major RGBA8
enum class ImageFormat { png, tga, bmp };

struct ConversionOptions { bool apply_lookup=false; std::optional<std::uint8_t> shade=std::nullopt; };
struct PostprocessOptions { bool apply_transparency_fix=true; bool apply_premultiply=false; bool apply_matte_hygiene=false; };

struct EncodedImage { ImageFormat format; std::uint32_t w,h; std::vector<std::byte> bytes; };

std::expected<ArtData, Error> load_art(std::span<const std::byte>);
std::expected<ArtData, Error> load_art_from_memory(std::span<const std::byte> blob, std::size_t off, std::size_t len);
std::optional<TileView>       tile(const ArtData&, std::size_t index) noexcept;
std::size_t                   tile_count(const ArtData&) noexcept;

std::expected<Palette, Error> load_palette(std::span<const std::byte>);

std::expected<Image, Error>   palette_to_rgba(const TileView&, const Palette&, const ConversionOptions& = {});
void                          postprocess_rgba(Image&, const PostprocessOptions& = {});

std::expected<EncodedImage, Error> encode_image(const Image&, ImageFormat /*, keep existing knobs */);
constexpr std::string_view          file_extension(ImageFormat) noexcept;

} // ns
```

## Adapters

```cpp
namespace art2img::v1::adapters {
std::expected<std::vector<std::byte>, core::Error> read_binary_file(const std::filesystem::path&);
std::expected<std::filesystem::path, core::Error>  write_binary_file(const std::filesystem::path&, std::span<const std::byte>);
std::expected<std::filesystem::path, core::Error>  write_text_file(const std::filesystem::path&, std::string_view);

struct GrpEntry { std::string name; std::uint32_t offset, size; };
struct GrpIndex { std::span<const std::byte> blob; std::vector<GrpEntry> entries; };
std::expected<GrpIndex, core::Error>                 parse_grp(std::span<const std::byte>);
std::expected<std::span<const std::byte>, core::Error> grp_find(const GrpIndex&, std::string_view name);

std::string format_animation_meta_json(const core::AnimationData& d, bool include_paths=true, bool include_palette=true, bool include_lookup=true, std::string schema="art2img.animation@1.0");
std::string format_manifest_json(const core::ExportManifest& m);
std::string format_manifest(<args>, <manifest_format>);
} // ns
```

## CLI contract (thin)

Inputs (mutually exclusive): `--art FILE` | `--stdin-art` | `--grp FILE` | `--stdin-grp` | `--art-dir DIR` | `--grp-dir DIR` (both non-recursive).
Common flags:

```
--mode inspect|export                    # default inspect
--palette FILE
--tiles START:END
--format png|tga|bmp                     # repeatable
--apply-transparency-fix on|off          # default on
--apply-premultiply                      # default off
--apply-matte-hygiene                    # default off
--out DIR                                # required for export
--jobs N                                 # default 1
--anim-format ini|json                   # default json
--manifest-json
--json                                   # inspect summary to stdout
```

Backward-compat parse-only aliases (emit deprecation warnings): `--no-transparency-fix`, `--export-animation`, `--anim-ini-filename`, `--no-anim-ini-references`. Maintain backward compatibility during transition with warnings. 

# Implementation details (by concern)

## GRP parsing (new)

Implement `parse_grp` per 12-byte `"KenSilverman"` signature, 32-bit LE file count, then `count` entries of 12-byte name, 32-bit size; data section follows table. Normalize names: trim trailing NUL/spaces, uppercase, store `offset` and `size`. `grp_find` returns `blob.subspan(offset, size)`; case-insensitive match. Use `std::format` in error messages. Integrates memory-first slicing.

**Testing Strategy**: Use actual Duke3D GRP files located at `~/games/duke3d` or `~/games/duke3d/DUKE3D.GRP` for format validation and edge case testing.

Wire into CLI: `--grp + --entry NAME` (Note: `--offset/--size` support removed per architectural review).

## Conversion

* Canonicalize `palette_to_rgba(TileView, Palette, ConversionOptions)`.
* Eliminate public `copy_column_major_to_row_major` and `ColumnMajorRowRange*` from headers; keep `TileView::at(x,y)` and `col_major_offset(x,y)`. Existing row-iterator remains private if benchmarked beneficial.
* Post steps in-order: transparency_fix → matte_hygiene → premultiply.

## Encoding

* Keep PNG/TGA/BMP paths as-is; surface via `encode_image(Image, ImageFormat)` returning `EncodedImage`. Do not regress per-format options; keep option plumbing internally.

## Animation metadata

* Keep INI generator intact. Add JSON writer: deterministic key order, hand-escaped, no third-party JSON. Expose via `adapters::format_animation_meta_json`. CLI flag `--anim-format ini|json`.

**JSON Format**: Use simple, flat structure with deterministic key ordering. No complex schema validation required. 

## CMake/tooling

* Remove `fmt` CPM and link. Migrate all `fmt::format/print` → `std::format`/`std::print`. Update CLI and library. 
* Keep CLI11 for now; no argument model rewrite.
* Ensure C++23, no feature-gate header.
* Update include directories for new header structure:
  ```cmake
  target_include_directories(art2img_core
    PUBLIC
      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/art2img/core>
      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/art2img/adapters>
  )
  ```
* Restructure source files into `core/`, `adapters/` subdirectories
* Update test CMakeLists.txt for new include paths
* Ensure proper linking between core and adapters components

# Flow diagrams

## Inspect

```
bytes <- file|stdin|grp(slice) → load_art(span) → stdout: {"version","tile_start","tile_end","count"}
→ if --anim-format: collect_animation() → write animation_meta.(json|ini)
```

## Export

```
art_bytes + pal_bytes → load_art(), load_palette()
for i in [start..end]:
  tv = tile(art,i)
  img = palette_to_rgba(tv,pal,conv)
  postprocess_rgba(img, post)
  for fmt in formats:
    enc = encode_image(img, fmt)
    write <out>/tile_{:04}{ext}
    manifest.tiles += record
→ if --manifest-json: write manifest.json
```

# Examples

## Row-major traversal with TileView

```cpp
auto tv = *core::tile(art, i);
core::Image img{tv.w, tv.h, std::vector<std::uint8_t>(std::size_t(tv.w)*tv.h*4)};
for (std::uint32_t y=0; y<tv.h; ++y) {
  auto* out = img.rgba.data() + (std::size_t(y)*tv.w)*4;
  for (std::uint32_t x=0; x<tv.w; ++x) {
    const auto pi = tv.at(x,y);
    const std::uint32_t rgba = palette_rgba(pal, pi); // internal helper
    std::memcpy(out + std::size_t(x)*4, &rgba, 4);
  }
}
```

## GRP entry by name to export

```cpp
auto grp = adapters::read_binary_file("DUKE3D.GRP").value();
auto idx = adapters::parse_grp(std::span<const std::byte>(grp.data(), grp.size())).value();
auto art_s = adapters::grp_find(idx, "TILES000.ART").value();
auto art   = core::load_art(art_s).value();
```

## Animation JSON emit

```cpp
const auto anim = core::collect_animation(art);
adapters::write_text_file(out/"animation_meta.json", adapters::format_animation_meta_json(anim));
```

# Refactor plan vs current repo (delta)

1. **API surfacing**

* Introduce `core/adapters/extras` folderization.
* Move existing headers into the above buckets; update `api.hpp` to re-export clean v1.
* Add `TileView::col_major_offset` and `at`. Replace public row-range in headers by this accessor; keep internals if needed. 
* Update all source and test files with new namespace qualifiers (`art2img::v1::core`, `art2img::v1::adapters`)

2. **Rename and deprecate**

* CLI flags: replace `--no-transparency-fix` with `--apply-transparency-fix on|off` while accepting old flag with warning. 

3. **Animation metadata**

* Keep INI exporter; add JSON builder `format_animation_meta_json`. 

4. **GRP minimal**

* Implement `parse_grp`/`grp_find`. Wire into CLI for memory-first slicing.

5. **Encoding contract**

* Keep PNG/TGA/BMP; return `EncodedImage`. Preserve per-format option structs; do not widen API. 

6. **CMake/tooling**

* Remove `fmt` CPM and linkage; port to `std::format`. Fix CLI linkage. 
* Update CMake include directories for new header structure
* Restructure source files into `core/`, `adapters/` subdirectories

7. **Docs**

* Update USAGE to positive `--apply-*`, `--anim-format`, GRP usage; add memory-first examples.
* Add MIGRATION with function/flag rename table.

# Task breakdown (fine-grained, ordered)

## Phase 0 – Drop fmt dependency

* Remove CPM `fmt` and `fmt::fmt` link from CLI target. 
* Verify no `fmt::` usages exist in code (already using `std::format`).
* Update CMakeLists.txt to remove fmt dependency.
* Tests: Verify build still works, CLI still functions correctly.

## Phase 1 – Header reorganization and namespace migration

* Create `include/art2img/{core,adapters,extras}` dirs; move headers.
* Update `api.hpp` to re-export new paths.
* Update all source files with new namespace qualifiers
* Update all test files with new include paths and namespace references
* **Critical**: Develop automated migration scripts for 50+ test files - use IDE refactoring tools where possible
* Build: no behavior change.
* Tests: Update include paths in all test files; verify all tests still pass.

**Migration Examples**:
```cpp
// Header includes before/after
#include <art2img/art.hpp>         → #include <art2img/core/art.hpp>
#include <art2img/convert.hpp>     → #include <art2img/core/convert.hpp>
#include <art2img/io.hpp>          → #include <art2img/adapters/io.hpp>

// Namespace before/after
using namespace art2img;           → using namespace art2img::v1::core;
auto result = to_rgba(...);        → auto result = palette_to_rgba(...);
```

**Risk Mitigation**: This phase is highest risk due to extensive test file changes. Execute with parallel test updates and maintain coverage throughout migration.

## Phase 2 – Convert module rename

* Add to_rgba -> `palette_to_rgba`;
* Add `TileView::col_major_offset/at`.
* Remove `ColumnMajorRowRange…` from public headers; keep `.cpp` internal if retained. Replace public mentions in headers/tests. 
* Tests: update includes; parity test old vs new.
* **Backward Compatibility**: Add deprecated inline aliases:
  ```cpp
  [[deprecated("Use palette_to_rgba instead")]] 
  inline auto to_rgba(...) { return palette_to_rgba(...); }
  
  [[deprecated("Use palette_to_rgba instead")]]
  inline auto indexed_to_rgba(...) { return palette_to_rgba(...); }
  ```

## Phase 3 – Postprocess normalization

* Introduce `PostprocessOptions { apply_transparency_fix, apply_premultiply, apply_matte_hygiene }`.
* Tests: toggle matrix to assert effect order.

## Phase 4 – Encoding surface tighten

* Expose `core::EncodedImage` + `file_extension()`.
* Retain `encode_image(ImageView…)` overloads internally; public takes `Image`. 
* Tests: golden PNG/TGA/BMP.

## Phase 5 – Animation JSON

* Implement `adapters::format_animation_meta_json` with deterministic escaper.
* Keep INI writer unchanged. 
* Tests: JSON keys, escaping, stable order.
* **Simple JSON Structure**: Use flat key-value format with deterministic ordering; no complex schema required

## Phase 6 – GRP adapter

* Implement `parse_grp` + `grp_find` per spec.
* Tests: bad signature, OOB table, OOB data, dup names, case-insensitive find.
* **Validation**: Test against real Duke3D GRP files at `~/games/duke3d` or `~/games/duke3d/DUKE3D.GRP`
* **No Synthetic GRP**: Use only real GRP files for positive testing; create minimal invalid data for negative test cases only

## Phase 7 – CLI reshape (thin, positive flags)

* Replace negative flag with `--apply-transparency-fix on|off`; accept old flag with warning. 
* Add `--mode inspect|export`, `--anim-format ini|json`, `--grp/--entry`, `--art-dir` non-recursive. (Note: `--offset/--size` removed per architectural review)
* Make `--out` mandatory for export; error if missing.
* Jobs default 1; parallelism tile-level only.
* Output: per-ART `<out>/<basename>/tiles/tile_{:04}{ext}`; optional `manifest.json`.
* **Backward Compatibility**: Maintain support for deprecated flags with warnings:
  ```cpp
  // Accept --no-transparency-fix but warn and convert to --apply-transparency-fix off
  // Accept --export-animation but warn about new --anim-format flag
  // Accept legacy flags during transition period
  ```

## Phase 8 – Docs

* Rewrite USAGE to new flags and flows; show GRP memory-first.
* MIGRATION mapping table:

  * `to_rgba`/`indexed_to_rgba` → `palette_to_rgba`.
  * `--no-transparency-fix` → `--apply-transparency-fix off`.
  * Add `--anim-format` and JSON.

## Phase 9 – Test migration and coverage

**Test Migration Strategy**:
- Unit tests: Move to appropriate test subdirectories matching source structure
- Integration tests: Update include paths and namespace references
- Maintain existing test coverage while adding new tests

**Unit Tests**:
- GRP parser: bad signature, OOB table/data, duplicate names, case-insensitive find
- JSON: deterministic key order, proper escaping, schema validation
- Conversion: `palette_to_rgba` parity, `postprocess_rgba` toggle matrix
- Encode: validity for small PNG/TGA/BMP outputs
- Case-insensitive helper functions
- Namespace migration validation
- Backward compatibility: deprecated function aliases, old CLI flags

**Integration Tests**:
- CLI inspect JSON output validation
- CLI export with manifest generation
- `--art-dir` batch processing with mixed-case filenames
- GRP file processing workflows
- Performance benchmarks (no regression in conversion speed)

**Test Resource Requirements**:
- Primary: `~/games/duke3d/DUKE3D.GRP` for GRP validation
- Secondary: `~/games/duke3d/` directory for multiple GRP files
- **No Synthetic GRP**: Use only real GRP files; create minimal invalid data for negative test cases only

# Migration table (public-facing)

| Before                       | After                                                         |       |
| ---------------------------- | ------------------------------------------------------------- | ----- |
| `to_rgba`, `indexed_to_rgba` | `palette_to_rgba`                |       |
| `--no-transparency-fix`      | `--apply-transparency-fix off`                                |       |
| INI-only animation           | `--anim-format ini                                            | json` |
| fmt formatting               | `std::format`/`std::print`                                    |       |
| Row-range helpers public     | `TileView::at()/col_major_offset()` public; iterators private |       |
| Flat namespace `art2img`     | Versioned namespaces `art2img::v1::core`, `art2img::v1::adapters` | |
| Flat header structure        | Modular `core/`, `adapters/`, `extras/` subdirectories        |       |

# Cleanups

* Remove `fmt` CPM and linkage. 
* Keep PNG/TGA/BMP only; no new codecs. 
* Remove deprecated function implementations after migration period
* Clean up unused header includes
* **Migration Tools**: Archive automated scripts used for header/namespace migration for future reference

Deliver this refactor without widening semantics; preserve performance; reduce public surface area; stabilize names and flags.
Branch-by-branch implementation. Conventional commits. PR per phase. Drop `--grp --offset/--size`. Enforce case-insensitive matching for files, extensions, and GRP entries. C++23 + `std::format`. Non-recursive `--art-dir`. Project already configured for C++23 in CMakeLists.txt.

# Delivery Strategy

## Single Branch Approach: `feature/v1.1-refactor`

All phases will be delivered through a single feature branch with smaller, focused commits grouped by functionality. Each commit must be validated, tested, building, and running before proceeding.

## Commit Grouping Strategy

### Phase 0 – Fmt Removal
**Commit Group**: `build-dependencies`
- `chore(build): remove fmt dependency from CMake`
- Validate: Build succeeds, CLI functions with std::format

### Phase 1 – Header/Namespace Migration
**Commit Group**: `core-structure`
- `feat(core): add TileView::at and col_major_offset`
- `feat(api): add barrel api.hpp re-exporting core and adapters`
- `refactor(include): move headers to core/ and adapters/ namespaces`
- `refactor(src): restructure source files into core/ and adapters/ directories`
- `refactor(namespace): migrate to art2img::v1::core and art2img::v1::adapters namespaces`
- `test: update include paths and namespace references in all test files`
- Validate: All tests pass, examples compile with only `#include <art2img/api.hpp>`

### Phase 2 – Convert Rename
**Commit Group**: `convert-api`
- `refactor(convert): rename to_rgba -> palette_to_rgba`
- `chore(convert): add deprecated inline aliases`
- Validate: Old codepaths compile via aliases, unit parity tests pass

### Phase 3 – Postprocess Normalization
**Commit Group**: `postprocess-options`
- `feat(convert): unify PostprocessOptions with apply-* flags`
- `test(convert): add toggle matrix tests`
- Validate: Toggling flags affects output as specified

### Phase 4 – Encode Surface
**Commit Group**: `encode-api`
- `feat(encode): EncodedImage return type and file_extension`
- `chore(encode): remove jpeg from public surface`
- Validate: Golden PNG/TGA/BMP outputs unchanged

### Phase 5 – GRP Parser
**Commit Group**: `grp-adapter`
- `feat(grp): parse group file format (KenSilverman, table, data)`
- `feat(grp): case-insensitive grp_find(name)`
- Validate: Unit tests for bad signature, OOB table/data, duplicate names, case variations

### Phase 6 – JSON Metadata
**Commit Group**: `json-metadata`
- `feat(meta): add JSON writers for animation and manifest`
- `test(meta): assert deterministic key order and escaping`
- Validate: Files `animation_meta.json`, `manifest.json` validate basic structure

### Phase 7 – CLI Reshape
**Commit Group**: `cli-refactor`
- `feat(cli): add inspect/export modes and positive apply-* flags`
- `feat(cli): support --grp --entry (drop offset/size)`
- `feat(cli): add --art-dir and --grp-dir non-recursive with case-insensitive *.ART/*.GRP`
- `feat(cli): case-insensitive formats and robust tiles parsing`
- `refactor(cli): filenames via std::format`
- `test(cli): smoke tests for inspect/export/art-dir/grp-dir`
- Validate: CLI commands work with new flags and modes

### Phase 8 – Documentation
**Commit Group**: `documentation`
- `docs: update README with memory-first examples`
- `docs: USAGE for CLI flags and GRP usage`
- `docs: MIGRATION to palette_to_rgba and --apply-*`
- Validate: Examples compile and run locally

### Phase 9 – Test Migration
**Commit Group**: `test-coverage`
- `test(unit): add coverage for convert/encode/grp/json`
- `test(integration): add cli smoke for inspect/export/art-dir`
- `test: migrate all existing tests to new namespace structure`
- `test: add comprehensive case-insensitive function tests`
- `test: add GRP parser edge case coverage`
- `test: add JSON metadata formatting validation`
- Validate: CI green, all tests pass, comprehensive coverage

### Phase 10 – Benchmarking
**Commit Group**: `performance-benchmarking`
- `benchmark: add comprehensive performance test suite`
- `benchmark: measure GRP extraction to PNG/TGA/BMP formats`
- `benchmark: add threading performance analysis`
- `ci: integrate performance regression testing`
- Validate: Performance metrics documented, no regression from baseline

## Validation Requirements for Each Commit

1. **Build Validation**: Must compile successfully
2. **Test Validation**: All relevant tests must pass
3. **Functionality Validation**: Core functionality must work as expected
4. **Backward Compatibility**: Deprecated features must continue to work
5. **Performance Validation**: No significant performance regression

## Cutover Sequence

1. Execute Phase 0 (fmt removal) first
2. Execute Phase 1 (header/namespace migration) - CRITICAL FOUNDATION
3. Execute phases 2–4 (API + encode)
4. Execute GRP (5), JSON meta (6)
5. Execute CLI (7)
6. Execute docs (8)
7. Execute tests (9)
8. Tag `v1.1.0`
9. Execute Phase 10 performance benchmarking

---

## 10) `benchmark/phase-10-performance-benchmarking`

**Scope**
- Comprehensive performance benchmarking of GRP extraction to all formats
- Measure time per tile, memory usage, and throughput
- Compare PNG/TGA/BMP performance characteristics
- Test single-threaded vs multi-threaded performance

**Changes**
- Create benchmark executable using Google Benchmark
- Add comprehensive performance test suite
- Generate performance reports and comparison data
- Integrate performance regression testing into CI

**Commits**
* `benchmark: add comprehensive performance test suite`
* `benchmark: measure GRP extraction to PNG/TGA/BMP formats`
* `benchmark: add threading performance analysis`
* `ci: integrate performance regression testing`

**PR title**
* `benchmark: comprehensive performance testing and analysis`

**Acceptance**
* Performance metrics documented for all formats
* No performance regression from baseline
* Automated performance regression detection
* Comprehensive format comparison data

---

# Global polish

* Remove `--grp --offset/--size` from parser, help, docs (removed per architectural review).
* Optional `--entry` with any `--grp`/`--stdin-grp`. All entries by default.
* Case-insensitive everywhere it matters:

  * GRP names (normalize to trimmed ASCII upper once in index; compare upper).
  * `--art-dir` extension filter (`.art`, any case).
  * `--grp-dir` extension filter (`.grp`, any case).
  * `--format` values (`png|tga|bmp`, any case).
  * Optional palette auto-discovery (if present): prefer exact, fallback case-insensitive `"PALETTE.DAT"` in the same dir.
* Non-recursive `--art-dir` and `--grp-dir`. No hidden breadth.
* Deterministic output ordering (lexicographic by uppercased filename).
* Error codes:

  * usage (64), io (65), parse (66), encode (67). Map `core::Error` to exit codes.
* Logging: concise; no progress bars; silent under `--json` except JSON itself.
* Filenames: `tile_{:04}{ext}`; per-ART layout `<out>/<fileoutput.ext>`.

---

# PR template (use on every phase)

**Title**: `feat|refactor|docs|test(scope): short summary`

**Checklist**

* [ ] Public headers unchanged except intended deltas
* [ ] Unit tests added/updated
* [ ] Integration tests passing
* [ ] Docs updated (if user-visible change)
* [ ] CLI help updated (`--help`)
* [ ] Namespace migrations completed
* [ ] Include paths updated throughout codebase
* [ ] Build system updated for new structure

**Risk**

* List any breaking behavior and mitigations.

**Notes**

* Benchmarks if relevant.

---

# Conventional commits map

* `feat(...)`: new API/CLI capability.
* `refactor(...)`: rename/move without behavior change.
* `fix(...)`: bug fix in encode/convert/cli.
* `docs(...)`: README/USAGE/MIGRATION.
* `test(...)`: unit/integration additions.
* `chore(...)`: build/tooling, dependency removal.

---

# Migration Tools & Risk Mitigation

## Automated Migration Requirements

**Phase 1 Critical Tools**:
- Header migration script: Update all `#include` paths from flat to modular structure
- Namespace migration tool: Automated refactoring for 100+ source/test references  
- Include path validator: Ensure all includes resolve correctly after migration
- Test parallel updater: Update tests in sync with source changes

**Complete Migration Script**:
```bash
#!/bin/bash
# Phase 1 Header Migration Script
set -euo pipefail

# Header migration
find . -name "*.cpp" -o -name "*.hpp" -o -name "*.h" | xargs sed -i \
  -e 's|#include <art2img/art.hpp>|#include <art2img/core/art.hpp>|g' \
  -e 's|#include <art2img/convert.hpp>|#include <art2img/core/convert.hpp>|g' \
  -e 's|#include <art2img/io.hpp>|#include <art2img/adapters/io.hpp>|g' \
  -e 's|#include <art2img/palette.hpp>|#include <art2img/core/palette.hpp>|g' \
  -e 's|#include <art2img/encode.hpp>|#include <art2img/core/encode.hpp>|g'

# Namespace migration  
find . -name "*.cpp" -o -name "*.hpp" -o -name "*.h" | xargs sed -i \
  -e 's|using namespace art2img;|using namespace art2img::v1::core;|g' \
  -e 's|art2img::Error|art2img::v1::core::Error|g' \
  -e 's|art2img::ImageFormat|art2img::v1::core::ImageFormat|g'

# Function rename migration
find . -name "*.cpp" -o -name "*.hpp" -o -name "*.h" | xargs sed -i \
  -e 's|\bto_rgba\b|palette_to_rgba|g' \
  -e 's|\bindexed_to_rgba\b|palette_to_rgba|g'

# Validation script
if grep -r "art2img::" --include="*.cpp" --include="*.hpp" | grep -v "art2img::v1"; then
  echo "ERROR: Found non-v1 namespace usage"
  exit 1
fi

echo "Phase 1 migration completed successfully"
```

## Risk Mitigation Strategies

1. **Phase 1 (Highest Risk)**: 
   - Execute with automated tooling
   - Maintain test coverage throughout migration
   - Backup files before migration
   - Validate changes with comprehensive testing

2. **GRP Format Validation**:
   - Test against real Duke3D files early
   - Validate format spec against multiple GRP files
   - Include edge case testing (corrupted files, empty entries)
   - **No synthetic GRP**: Use only real files for positive testing

3. **Backward Compatibility**:
   - Maintain deprecation aliases for transition period
   - Comprehensive CLI flag compatibility testing
   - Clear migration documentation

# Cutover sequence

1. Execute Phase 0 (fmt removal) first
2. Execute Phase 1 (header/namespace migration) - CRITICAL FOUNDATION
3. Execute phases 2–4 (API + encode)
4. Execute GRP (5), JSON meta (6)
5. Execute CLI (7)
6. Execute docs (8)
7. Execute tests (9)
8. Tag `v1.1.0`
9. Execute Phase 10 performance benchmarking

All phases adhere to the constraints: C++23 + `std::format`, memory-first library, PNG/TGA/BMP only, GRP by entry name only, case-insensitive discovery, non-recursive `--art-dir`|`--grp-dir`. Tests use doctest framework and will need include path updates during refactoring.

**Key Testing Resources**: Use `~/games/duke3d` or `~/games/duke3d/DUKE3D.GRP` for GRP format validation throughout development.

## Phase 10 – Performance Benchmarking

**Scope**
- Comprehensive performance benchmarking of GRP extraction to all formats
- Measure time per tile, memory usage, and throughput
- Compare PNG/TGA/BMP performance characteristics
- Test single-threaded vs multi-threaded performance

**Benchmark Metrics**
- Time per tile extraction (milliseconds)
- Memory usage during processing (MB)
- Format encoding performance comparison
- Thread scaling efficiency
- GRP parsing performance
- Throughput (tiles/second)

**Implementation**
- New benchmark executable using Google Benchmark
- Test with multiple GRP file sizes and tile counts
- Generate comprehensive performance reports
- Integrate with CI for performance regression testing
- Compare performance across all output formats (PNG/TGA/BMP)

**Test Data**
- Use real Duke3D GRP files for benchmarking
- Test with various tile sizes and complexities
- Include both small and large GRP files

**Acceptance Criteria**
- No performance regression from baseline
- Clear performance metrics documentation
- Automated performance regression detection
- Comprehensive format comparison data
- Threading performance analysis

**Performance Validation**
- Benchmark conversion speed before/after refactoring
- Measure GRP parsing performance 
- Monitor memory usage changes
- Ensure no performance regression in critical paths

